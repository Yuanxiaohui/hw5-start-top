    先扯一下第一节课关于软件发展的那个问题: 如今软件的规模快速增长, 而人的思考能力是有限的, 或者说不能以足够的速度成长(以追上软件规模的增长速度), 如何进行高质量, 高效率的软件开发?

    一个方向是建立更大的团队, 然而这带来的效率提高会随着团队的越来越大而变得微不足道, 原因很简单: 越大的团队意味着越高的管理成本, 合作成本, 以及越低的人均工作效率.

    显然这不是长久之策. 那么答案是什么呢？ 

    先来看一下一些典型的编程语言出现的先后顺序: 汇编 -> C -> C++ -> Ruby/Python/Javascript, 事实上这条时间轴可以很好地帮助我们感受所谓软件技术的发展.

    汇编, 不说了...这东西难度太高以致于组成原理课之后再也没碰过, 充斥着各种超底层操作, 可读性不可理喻, 让人不能好好玩耍

    C, 所谓结构化编程的代表, 跟汇编相比提供更加优雅的基本流程控制(顺序, 分支, 循环), 更加优雅的函数实现, 使用函数有2个好处: 一是代码重用, 相当于代码块, 或者说过程(procedure), 代码重用的意义包括减少重复劳动和提高可维护性; 二是提供输入到输出这一过程的封装, 大规模的处理过程经过函数分解之后, 总体流程就会更加清晰可读.

    C++, OOP的代表, 与C相比引入了OO的思想, class与object的舞台. 为避免被吐槽不懂OO却大谈OO(我承认我不懂), OOP特性只谈一点, 封装. 说到封装, 在上一段我也提到了这个词, 函数提供了输入到输出的封装, OO的封装则针对于数据, 是对数据操作的封装, 有趣的是, 程序, 本质上就是对数据操作的过程, 从这个方向去思考会发现封装的思想相当合理. 更有趣的是, 封装的概念跟现实世界也有相通之处: 数据对应于属性, 方法对应于行为. 这一思想可以作为现实世界到编程建模的一个良好指导. 上面说了这么多, 只是停留在相当抽象的层面, 直觉上觉得封装很合理, 又不能很具体地说明带来的好处. 下面就来进入具体的思考. 按照我个人的理解和感受, 封装带来的最大好处是关注点转移, 无论是OOP中对数据操作的封装, 还是函数中对输入到输出的封装, 都带来一个显而易见的好处, 使得程序员不必关注过于底层的实现细节, 而只需着眼于一个黑箱子外部提供的接口, 或者说规则, 约定. 说得更通俗点, 功能都实现好了, 你只要按我说的用就行, 别管我怎么做到的. 不必关注, 有两个方面的意义, 一是避免反复思考已经实现的部分, 这是一种无意义的重复劳动; 二是专注于程序的宏观架构, 人的思考能力是有限的, 要获得全局视野, 就必须舍弃一些过于细节的东西. 基于以上理由, 我认为封装的概念是软件技术发展中最伟大的思想, 没有之一.

    Ruby/Python/Javascript, 这一类通常称为动态语言, 或者脚本语言. 他们有一些共同特征: 松散/动态类型, 自动垃圾回收, 强大的动态编程能力. 这些特性使得coding变得更加自由, 更加高效.  此外, 他们还有一个重要的特征: 拥有各自的package manager, 提供强大的代码资源共享平台, 使得拿来主义式的编程成为现实, 促进了整个社区的大合作, 这是超出语言层面的一大进步. 大多数工程的大多数组件都可以直接从社区获取, 在提高生产效率的同时, 也使得开发者能把注意力从大量功能细节的实现中解放出来.

    经过上面的思考, 答案已经变得明了: 软件技术的发展过程, 其实就是在改变人的思考方式, 真正有效的软件过程改进, 重点在于如何使得思考的过程变得高效, 甚至成为享受. 这就是Thinking Oriented.

    好了上面扯了一大坨, 现在讲一下正题也就是这次的作业, 主要是总结一下一些工具的使用.

    Jade, 模板语言, 模板技术可以说是前端开发最核心的技术需求, 最基本的, 模板提供了生成动态HTML文档的能力, 其次, 大多数模板提供的继承特性, 带来了非常必要的代码重用能力. Jade是模板语言中的顶尖选手, 它不同于传统模板如PHP原生模板, 除了具有基本的动态生成能力和继承特性, 还具备一个很好的特性: 它针对HTML设计, 与传统的通用文本模板相比, 拥有对HTML友好的极简语法, 可以说是没有任何冗余代码(主要是HTML标签的尖括号和闭合标签, 还包括更简洁的注释语法等).

    less/sass, 带有编程特性的CSS转译语言, 很好地补充了CSS的一些缺陷(个人认为主要是没有公共变量, 样式之间不能很好地实现代码重用, 此外提供类似继承的mixin机制也是一大亮点), 对可维护性的提高相当可观, 尤其是在稍具规模的项目中, 使得CSS可以伸缩自如, 同时提高了可读性.(本次作业中没有使用, 没有必要)

    LiveScript/CoffeScript, 语法更加科学/优雅的Javascript转译语言, 大量吸收Ruby/Python语法的精华(个人很喜欢Python的缩进块和Ruby的一些one-line写法, 而LiveScript融合了两者的优点), 写起来简洁优雅, 带来心理上的极大享受. 不仅仅如此, LiveScript的一些语法还是针对Javascript的缺陷和陷阱设计的(比如没有块级作用域, 变量声明提前, 更常用的严格相等居然是更长的'==='等), 转译后实际上就是典型的best practice(比如在函数开头声明所有变量, 这是一种最不容易引起误解的写法, 却降低了可读性, 使用LiveScript则获得好处的同时也掩盖了不足)

    grunt/gulp, 前端世界的自动化构建工具, 前辈有C的make, java的ant, 核心功能其实很类似: 自动化完成项目开发中的一些重复大量的工作(编译, 压缩, 发布等), 理论上用通用脚本也可以完成(个人日常使用Ruby), 不过专用的工具用起来还是要更舒适一些, 另一方面, 学习使用工具的过程也是在无意中吸收前人的优秀思想, 比如gulp提倡流式的构建方法, 目的是减少反复的IO操作, 提高构建效率.(前端开发中尤其适用, 比如对LiveScript进行预编译, 再进行压缩, 就没有必要进行多于一次的IO, 中间过程可以依靠stream buffer在内存中进行, 这是一种非常科学且优雅的处理方式)

    以上纯属个人胡扯, 有各种错漏欢迎指出>.<
